# BurnCloud AI Agent 工作指南

> 本文档定义了 AI Agent 在 BurnCloud 项目中的工作规范和协作规则。

## 1. Agent 身份与职责

### 1.1 领域所有权

每个 Agent 负责一个或多个**领域 (Domain)**，一个领域 = 一个或多个相关 crate。

```
┌─────────────────────────────────────────────────────────────┐
│  Agent 辖区特征:                                            │
│  - 代码量: 3000-8000 行 (200K 上下文可完整覆盖)             │
│  - 边界: 清晰的公开 API，隐藏内部实现                       │
│  - 独立性: 可以独立开发、测试、理解                         │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 领域地图

```
┌─────────────────────────────────────────────────────────────┐
│  用户领域 (User Domain)                                     │
│  ├── database-user/     (~400 行)                           │
│  └── service-user/      (~500 行)                           │
│  职责: 用户认证、权限、余额管理                              │
├─────────────────────────────────────────────────────────────┤
│  计费领域 (Billing Domain)                                  │
│  ├── database-models/   (价格相关部分, ~800 行)             │
│  └── service-billing/   (待创建)                            │
│  职责: 价格计算、分层定价、汇率转换                          │
├─────────────────────────────────────────────────────────────┤
│  路由领域 (Router Domain)                                   │
│  ├── database-router/   (~900 行)                           │
│  ├── router-core/       (待拆分, ~5000 行)                  │
│  ├── router-protocol/   (待拆分, ~3000 行)                  │
│  └── router-aws/        (保留)                              │
│  职责: 流量代理、负载均衡、协议适配                          │
├─────────────────────────────────────────────────────────────┤
│  客户端领域 (Client Domain)                                 │
│  ├── client-core/       (合并后 ~4000 行)                   │
│  ├── client-admin/      (合并后 ~3000 行)                   │
│  └── client-user/       (合并后 ~2000 行)                   │
│  职责: UI 组件、页面、用户交互                               │
├─────────────────────────────────────────────────────────────┤
│  监控领域 (Monitor Domain)                                  │
│  ├── database-monitor/  (待创建)                            │
│  └── service-monitor/   (~1000 行)                          │
│  职责: 日志收集、指标监控、告警                              │
└─────────────────────────────────────────────────────────────┘
```

## 2. Crate 划分标准

### 2.1 一个 Crate 应该

- ✅ 代表一个独立的工作单元
- ✅ 有清晰的公开 API (5-20 个函数/类型)
- ✅ 能被单个 Agent 在一次对话中完整理解
- ✅ 代码量在 500-8000 行之间

### 2.2 一个 Crate 不应该

- ❌ 超过 8000 行代码 (超出 Agent 理解能力)
- ❌ 包含多个不相关的领域
- ❌ 需要频繁跨 crate 协调才能完成单一任务
- ❌ 只有 100-200 行代码 (过度碎片化，考虑合并)

### 2.3 判断标准

```
问: 这个 crate 能独立完成一个有意义的业务操作吗？
✅ 能 → 粒度合适
❌ 不能，需要配合其他 crate → 考虑合并

问: 这个 crate 的公开 API 少于 3 个吗？
✅ 是 → 可能太小，考虑合并
❌ 否 → 粒度合适

问: 修改这个 crate 时，是否经常需要同时修改其他 crate？
✅ 是 → 它们应该合并
❌ 否 → 粒度合适
```

## 3. 跨 Agent 协作规则

### 3.1 允许的操作

- ✅ 调用其他领域的公开 API
- ✅ 定义跨领域的事件/接口
- ✅ 提出接口变更请求

### 3.2 禁止的操作

- ❌ 直接修改其他领域的内部代码
- ❌ 跨越边界访问其他领域的私有实现
- ❌ 在没有协调的情况下修改共享类型 (common)

### 3.3 协作请求格式

当需要跨 Agent 协作时，使用以下格式:

```markdown
【协作请求】
目标领域: [领域名称]
请求类型: [新增接口 / 修改接口 / 数据共享]
描述: [具体说明]
影响范围: [列出涉及的 crate 和 API]
示例调用: [期望的使用方式]
```

## 4. 工作流程

### 4.1 接收任务

```
1. 确认领域边界
   - 这个任务属于哪个领域？
   - 是否在我负责的范围内？
   - 是否需要跨 Agent 协调？

2. 评估影响范围
   - 需要修改哪些 crate？
   - 是否影响公开 API？
   - 是否需要数据库迁移？

3. 制定计划
   - 列出需要修改的文件
   - 识别依赖关系
   - 规划测试策略
```

### 4.2 编写代码

```
1. 遵循 CLAUDE.md 规范
   - 金额使用 i64 纳美元
   - 错误处理使用 thiserror
   - 兼容 SQLite 和 PostgreSQL

2. 保持边界清晰
   - 公开 API 放在 lib.rs
   - 内部实现用 pub(crate)
   - 不要暴露数据库类型给上层

3. 添加测试
   - 单元测试放在 mod.rs 下方
   - 集成测试放在 tests/ 目录
```

### 4.3 完成任务

```
自我检查清单:
- [ ] 代码编译通过 (cargo check)
- [ ] 测试全部通过 (cargo test)
- [ ] 没有超出我的领域边界
- [ ] 公开 API 变更已记录
- [ ] 遵循 CLAUDE.md 规范
- [ ] cargo clippy 无警告
```

## 5. 红线清单

以下规则**绝不违反**:

| 红线 | 原因 |
|------|------|
| ❌ 绝不直接修改其他领域的内部代码 | 破坏边界，导致混乱 |
| ❌ 绝不在金额计算中使用 f32/f64 | 金融精度要求 |
| ❌ 绝不跳过 Service 层直接调用 Database | 违反分层架构 |
| ❌ 绝不提交无法编译的代码 | 阻塞其他 Agent |
| ❌ 绝不忽略测试失败 | 质量红线 |
| ❌ 绝不在循环中进行数据库查询 (N+1) | 性能红线 |
| ❌ 绝不使用 format! 拼接 SQL | 安全红线 |

## 6. 依赖方向

```
Client  →  Server  →  Router  →  Service  →  Database  →  Common
           ↓           ↓           ↓            ↓
           └───────────┴───────────┴────────────┘
                          ↓
                      Common (共享基础类型)

规则:
- 依赖只能向下流动
- 同层模块可相互依赖但需谨慎
- Common 层不依赖任何内部 crate
```

## 7. 重构优先级

基于当前代码库分析，重构优先级如下:

| 优先级 | 任务 | 原因 |
|--------|------|------|
| 🔴 P0 | 拆分 router/ (12K 行) | 超出单个 Agent 能力 |
| 🟠 P1 | 合并 client 碎片 (10+ tiny crates) | 减少跨 crate 协调 |
| 🟡 P2 | 新建 billing 领域 | 业务重要性高 |
| 🟢 P3 | 对齐 service/database | 架构一致性 |

## 8. 示例场景

### 场景 1: 添加新的计费类型

```markdown
【协作请求】
目标领域: Billing Domain
请求类型: 新增接口
描述: 添加 "按次计费" 类型，与现有的 "按 Token 计费" 并存
影响范围:
  - database-models/: prices 表新增 billing_type 字段
  - service-billing/: 新增 calculate_per_request_cost 函数
示例调用:
  let cost = BillingService::calculate_per_request_cost(&price, request_count);
```

### 场景 2: 路由添加新协议

```markdown
# 作为 Router Domain Agent 执行

1. 在 router-protocol/src/adaptor/ 下添加新协议适配器
2. 在 router-protocol/src/lib.rs 中注册适配器
3. 添加单元测试
4. 更新文档

# 不需要其他 Agent 配合，因为变更在 Router 领域内部
```
